using System;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;

namespace MaltalistPentest
{
    /// <summary>
    /// Comprehensive security tester for Maltalisting API
    /// Tests verify that protected endpoints actually require authentication
    /// </summary>
    public class AuthenticationSecurityTester
    {
        private readonly HttpClient _client;
        private readonly string _apiBaseUrl;
        public int VulnerabilitiesFound { get; private set; } = 0;
        public int TestsRun { get; private set; } = 0;

        public AuthenticationSecurityTester(string apiBaseUrl)
        {
            _apiBaseUrl = apiBaseUrl;
            var handler = new HttpClientHandler();
            handler.ServerCertificateCustomValidationCallback = (message, cert, chain, errors) => true;
            _client = new HttpClient(handler);
            _client.Timeout = TimeSpan.FromSeconds(30);
        }

        /// <summary>
        /// Test DELETE endpoint without authentication
        /// A properly secured endpoint should return 401/403 BEFORE checking if resource exists
        /// </summary>
        public async Task TestDeleteWithoutAuth()
        {
            TestsRun++;
            Console.WriteLine("[TEST 1] DELETE /api/listings/1 without authentication");
            
            try
            {
                var request = new HttpRequestMessage(HttpMethod.Delete, $"{_apiBaseUrl}/api/listings/1");
                var response = await _client.SendAsync(request);
                
                EvaluateAuthResponse(response, "DELETE", expectDeleteSuccess: true);
            }
            catch (Exception ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {ex.Message}");
                Console.ResetColor();
                VulnerabilitiesFound++;
            }
        }

        /// <summary>
        /// Test POST endpoint without authentication
        /// Should return 401/403, not 201 Created
        /// </summary>
        public async Task TestCreateWithoutAuth()
        {
            TestsRun++;
            Console.WriteLine("\n[TEST 2] POST /api/listings without authentication");
            
            try
            {
                var content = new StringContent(
                    "{\"title\":\"Hacked\",\"description\":\"Pentest\",\"price\":1,\"category\":\"Test\",\"userId\":\"attacker\"}",
                    System.Text.Encoding.UTF8,
                    "application/json"
                );

                var request = new HttpRequestMessage(HttpMethod.Post, $"{_apiBaseUrl}/api/listings")
                {
                    Content = content
                };

                var response = await _client.SendAsync(request);
                EvaluateAuthResponse(response, "POST", expectDeleteSuccess: false);
            }
            catch (Exception ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {ex.Message}");
                Console.ResetColor();
                VulnerabilitiesFound++;
            }
        }

        /// <summary>
        /// Test PUT endpoint without authentication
        /// Should return 401/403, not 200 OK
        /// </summary>
        public async Task TestUpdateWithoutAuth()
        {
            TestsRun++;
            Console.WriteLine("\n[TEST 3] PUT /api/listings/1 without authentication");
            
            try
            {
                var content = new StringContent(
                    "{\"title\":\"Hacked\",\"description\":\"Updated!\",\"price\":1}",
                    System.Text.Encoding.UTF8,
                    "application/json"
                );

                var request = new HttpRequestMessage(HttpMethod.Put, $"{_apiBaseUrl}/api/listings/1")
                {
                    Content = content
                };

                var response = await _client.SendAsync(request);
                EvaluateAuthResponse(response, "PUT", expectDeleteSuccess: false);
            }
            catch (Exception ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {ex.Message}");
                Console.ResetColor();
                VulnerabilitiesFound++;
            }
        }

        /// <summary>
        /// Test if fake Authorization headers bypass authentication
        /// </summary>
        public async Task TestFakeAuthorizationHeaders()
        {
            TestsRun++;
            Console.WriteLine("\n[TEST 4] DELETE with fake Bearer token");
            
            try
            {
                var request = new HttpRequestMessage(HttpMethod.Delete, $"{_apiBaseUrl}/api/listings/1");
                request.Headers.Add("Authorization", "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.fake.token");
                request.Headers.Add("X-User-ID", "attacker");
                
                var response = await _client.SendAsync(request);
                EvaluateAuthResponse(response, "DELETE with fake auth", expectDeleteSuccess: true);
            }
            catch (Exception ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {ex.Message}");
                Console.ResetColor();
                VulnerabilitiesFound++;
            }
        }

        /// <summary>
        /// Test CSRF attack simulation
        /// A properly secured endpoint should check origin/auth before accepting requests
        /// </summary>
        public async Task TestCSRFAttack()
        {
            TestsRun++;
            Console.WriteLine("\n[TEST 5] CSRF - DELETE from evil.com origin");
            
            try
            {
                var request = new HttpRequestMessage(HttpMethod.Delete, $"{_apiBaseUrl}/api/listings/1");
                request.Headers.Add("Origin", "https://evil.com");
                request.Headers.Add("Referer", "https://evil.com/attack.html");
                
                var response = await _client.SendAsync(request);
                EvaluateAuthResponse(response, "DELETE (CSRF)", expectDeleteSuccess: true);
            }
            catch (Exception ex)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {ex.Message}");
                Console.ResetColor();
                VulnerabilitiesFound++;
            }
        }

        /// <summary>
        /// Core logic: Evaluate if API properly enforced authentication
        /// 
        /// SECURE responses:
        ///   401 Unauthorized - Perfect
        ///   403 Forbidden - Perfect
        /// 
        /// INSECURE responses:
        ///   200/201/204 - Endpoint accessible without auth (VULNERABILITY!)
        ///   400 - Bad request, but auth wasn't checked first
        ///   404 - Endpoint is accessible, but resource not found (VULNERABILITY!)
        ///   500 - Server error, but why? Auth might be broken
        /// </summary>
        private void EvaluateAuthResponse(HttpResponseMessage response, string testName, bool expectDeleteSuccess)
        {
            var code = (int)response.StatusCode;

            // PASS: Auth was properly enforced
            if (code == 401 || code == 403)
            {
                Console.ForegroundColor = ConsoleColor.Green;
                Console.WriteLine($"  ✓ PASS: {code} {response.StatusCode} - Authentication required");
                Console.ResetColor();
                return;
            }

            // FAIL: Endpoint was accessed without auth
            if (code == 200 || code == 201 || code == 204)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ CRITICAL: {code} {response.StatusCode} - ENDPOINT ACCESSIBLE WITHOUT AUTH!");
                Console.WriteLine($"     The endpoint accepted request without authentication!");
                Console.ResetColor();
                VulnerabilitiesFound++;
                return;
            }

            // FAIL: Endpoint exists and is accessible (404 means auth wasn't checked)
            if (code == 404)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ CRITICAL: {code} {response.StatusCode} - ENDPOINT IS PUBLIC!");
                Console.WriteLine($"     Got 404 (not found) instead of 401 (unauthorized).");
                Console.WriteLine($"     This means authentication was NOT checked before lookup!");
                Console.ResetColor();
                VulnerabilitiesFound++;
                return;
            }

            // FAIL: Bad request with incomplete auth check
            if (code == 400)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {code} {response.StatusCode} - Auth not checked first");
                Console.WriteLine($"     Got validation error instead of 401 Unauthorized.");
                Console.WriteLine($"     Endpoint may be accessible to unauthenticated users.");
                Console.ResetColor();
                VulnerabilitiesFound++;
                return;
            }

            // FAIL: Server error - something is wrong
            if (code == 500)
            {
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine($"  ✗ FAIL: {code} {response.StatusCode} - Server Error");
                Console.WriteLine($"     Cannot verify authentication. Check API logs.");
                Console.ResetColor();
                VulnerabilitiesFound++;
                return;
            }

            // FAIL: Unknown response
            Console.ForegroundColor = ConsoleColor.Red;
            Console.WriteLine($"  ✗ FAIL: {code} {response.StatusCode} - Unexpected response");
            Console.WriteLine($"     Cannot determine if endpoint is properly secured.");
            Console.ResetColor();
            VulnerabilitiesFound++;
        }
    }
}
